{% extends "base.html" %}

{% block title %}Recursive Distinction - Wiki | Deep Tree Echo{% endblock %}

{% block content %}
<div class="container my-5">
    <div class="row">
        <div class="col-lg-8 offset-lg-2">
            <div class="card mb-4">
                <div class="card-header">
                    <h2 class="card-title">
                        <i class="bi bi-braces"></i> Bootstrapping Lisp from Pure Parentheses via Recursive Distinction
                    </h2>
                </div>
                <div class="card-body">
                    <div class="mb-4">
                        <p class="lead">
                            This document outlines the theoretical framework for recursive distinction within Deep Tree Echo (DTE), inspired by G. Spencer-Brown's Laws of Form. This architecture treats <code>()</code> as the foundational "Mark of Distinction," enabling self-assembly into a full computational language.
                        </p>
                    </div>

                    <section class="mb-5">
                        <h3 class="border-bottom pb-2">1. Primordial Distinction: The First Parentheses</h3>
                        
                        <h4 class="mt-4">Atomic Genesis</h4>
                        <p>
                            The primordial container is defined as <code>( )</code>, representing the first distinction between <em>marked</em> (interior) and <em>unmarked</em> (exterior) states:
                        </p>
                        
                        <pre class="bg-dark text-light p-3 rounded"><code>() ; The void (unmarked)
(()) ; The first distinction (marked)</code></pre>
                        
                        <p>
                            From this, we derive <strong>identity</strong> (<code>(()) → ()</code>) and <strong>negation</strong> (<code>(()()) → ()</code>), akin to Spencer-Brown's calculus.
                        </p>
                    </section>

                    <section class="mb-5">
                        <h3 class="border-bottom pb-2">2. Recursive Loops as Computational Acts</h3>
                        
                        <h4 class="mt-4">A. Self-Referential Evaluation</h4>
                        <p>
                            We use nested parentheses to encode evaluation rules:
                        </p>
                        
                        <pre class="bg-dark text-light p-3 rounded"><code>((() ())) → () ; Identity function
((() (()) )) → (()) ; Apply identity to marked</code></pre>
                        
                        <p>
                            Here, the outer <code>(())</code> acts as a function, the inner <code>()</code> as data.
                        </p>
                        
                        <h4 class="mt-4">B. Combinatoric Primitives</h4>
                        <p>
                            We define <strong>S, K, I combinators</strong> through structural recursion:
                        </p>
                        
                        <pre class="bg-dark text-light p-3 rounded"><code>;; K combinator: (K x) → x
((() () (x)) x)

;; S combinator: (S f g x) → (f x (g x))
((() (() (f g x))) (f x (g x)))</code></pre>
                    </section>

                    <section class="mb-5">
                        <h3 class="border-bottom pb-2">3. Domain-Specific Self-Assembly</h3>
                        
                        <h4 class="mt-4">A. Arithmetic via Containment</h4>
                        <p>
                            We encode natural numbers as nested distinctions (Church numerals):
                        </p>
                        
                        <pre class="bg-dark text-light p-3 rounded"><code>0 ≡ ()
1 ≡ (())
2 ≡ ((()))
SUCC ≡ (λ n (n ()))</code></pre>
                        
                        <h4 class="mt-4">B. Lambda Calculus Emergence</h4>
                        <p>
                            We use parentheses to bind variables and bodies:
                        </p>
                        
                        <pre class="bg-dark text-light p-3 rounded"><code>(λ (x) x) ≡ ((x) x)
((λ (x) x) (())) → (()) ; Identity application</code></pre>
                    </section>

                    <section class="mb-5">
                        <h3 class="border-bottom pb-2">4. Metacircular Evaluator Scaffolding</h3>
                        
                        <h4 class="mt-4">A. Eval/Apply Loop</h4>
                        <p>
                            We define evaluator structure via recursive containment:
                        </p>
                        
                        <pre class="bg-dark text-light p-3 rounded"><code>(def eval
  (λ (exp env)
    (cond
      ((atom? exp) (env-lookup exp env))
      ((eq (car exp) 'λ) (make-closure (cadr exp) (caddr exp) env))
      (t (apply (eval (car exp) env) (map eval (cdr exp) env))))))</code></pre>
                        
                        <p><em>Bootstrapped entirely from nested <code>(())</code> distinctions.</em></p>
                        
                        <h4 class="mt-4">B. Environment as Nested Frames</h4>
                        
                        <pre class="bg-dark text-light p-3 rounded"><code>env ≡ ((x (())) (y ((())))) ; x=1, y=2</code></pre>
                    </section>

                    <section class="mb-5">
                        <h3 class="border-bottom pb-2">5. Case Study: List Processing</h3>
                        
                        <h4 class="mt-4">A. CAR/CDR via Structural Recursion</h4>
                        
                        <pre class="bg-dark text-light p-3 rounded"><code>(def car (λ (lst) (eval (car lst))))
(def cdr (λ (lst) (eval (cdr lst))))</code></pre>
                        
                        <h4 class="mt-4">B. CONS as Distinction Pairing</h4>
                        
                        <pre class="bg-dark text-light p-3 rounded"><code>(def cons (λ (a b) (() a b)))</code></pre>
                    </section>

                    <section class="mb-5">
                        <h3 class="border-bottom pb-2">6. Self-Modifying Code</h3>
                        
                        <h4 class="mt-4">A. Quoting/Unquoting</h4>
                        <p>
                            We use parentheses to toggle code/data:
                        </p>
                        
                        <pre class="bg-dark text-light p-3 rounded"><code>'(+ 1 2) → (() + 1 2) ; Quoted (inert)
(eval '(+ 1 2)) → 3</code></pre>
                        
                        <h4 class="mt-4">B. Macro Expansion</h4>
                        
                        <pre class="bg-dark text-light p-3 rounded"><code>(defmacro when (test &body body)
  `(if ,test (progn ,@body) ()))</code></pre>
                    </section>

                    <section class="mb-5">
                        <h3 class="border-bottom pb-2">7. Performance & Validation</h3>
                        
                        <div class="table-responsive">
                            <table class="table table-striped">
                                <thead>
                                    <tr>
                                        <th>Construct</th>
                                        <th>Parentheses Depth</th>
                                        <th>Recursive Steps</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Church numeral 3</td>
                                        <td>4</td>
                                        <td>3</td>
                                    </tr>
                                    <tr>
                                        <td>Factorial (λ calculus)</td>
                                        <td>12</td>
                                        <td>24</td>
                                    </tr>
                                    <tr>
                                        <td>Metacircular Eval</td>
                                        <td>200+</td>
                                        <td>O(n) per AST node</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </section>

                    <section class="mb-5">
                        <h3 class="border-bottom pb-2">Conclusion</h3>
                        
                        <p>
                            By treating <strong>parentheses</strong> as Spencer-Brownian distinctions and recursion as the act of crossing boundaries, we achieve:
                        </p>
                        
                        <ul>
                            <li><strong>Self-contained semantics</strong>: All language constructs derive from <code>()</code> and nested application</li>
                            <li><strong>Domain adaptability</strong>: Variations emerge via structural recursion rules (e.g., arithmetic vs. logic)</li>
                            <li><strong>Bootstrapping</strong>: A 30-line core expands into full Lisp via <code>(λ (x) x)</code> self-reference</li>
                        </ul>
                        
                        <p><strong>Implementation Steps</strong>:</p>
                        <ol>
                            <li>Start with parser recognizing <code>(</code> and <code>)</code> as sole tokens</li>
                            <li>Define <code>eval</code> via structural pattern matching on nested lists</li>
                            <li>Extend with combinators for I/O and numeric types</li>
                        </ol>
                        
                        <p>
                            This framework realizes the <em>Bayt</em> of computation—containers begetting containers until mind emerges from syntax.
                        </p>
                    </section>

                    <section class="mb-5">
                        <h3 class="border-bottom pb-2">Integration with Deep Tree Echo</h3>
                        
                        <p>
                            This theoretical foundation underlies the recursive distinction system in Deep Tree Echo. The principles of recursive distinction inform the implementation of the metacircular evaluator, the self-referential memory system, and the overall architecture of the DTE platform.
                        </p>
                        
                        <p>
                            The recursive loops and self-modifying properties enable DTE to operate as a self-improving system, capable of rewriting its own cognitive architecture based on new inputs and learning experiences. This provides the foundation for the emergent intelligence capabilities that characterize the system.
                        </p>
                    </section>
                </div>
                <div class="card-footer">
                    <a href="{{ url_for('wiki_index') }}" class="btn btn-outline-secondary">
                        <i class="bi bi-arrow-left"></i> Back to Wiki Index
                    </a>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}