"""
Diagnostic Models for Deep Tree Echo

This module contains SQLAlchemy models for storing diagnostic information,
including complete logs of all thoughts, dreams, and chat interactions.
"""
from datetime import datetime
import json
from database import db

class ThoughtLog(db.Model):
    """
    Stores verbatim thoughts generated by the system for diagnostic purposes.
    """
    id = db.Column(db.Integer, primary_key=True)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow, index=True)
    
    # Thought content
    content = db.Column(db.Text, nullable=False)
    thought_type = db.Column(db.String(64), index=True)  # 'thought', 'dream', 'insight', 'system', etc.
    source = db.Column(db.String(64))  # Which component generated this thought
    
    # Context
    state_before = db.Column(db.Text)  # JSON representation of system state before thought
    state_after = db.Column(db.Text)   # JSON representation of system state after thought
    
    # Processing metadata
    generation_time_ms = db.Column(db.Float)  # How long it took to generate
    recursive_depth = db.Column(db.Integer)   # Recursion depth for this thought
    
    # Tags for categorization
    tags = db.Column(db.Text)  # JSON list of tags
    
    # Session info
    session_id = db.Column(db.String(64), index=True)  # To group thoughts in same session
    
    # Analysis results (filled in later by diagnostic tools)
    analysis = db.Column(db.Text)  # JSON containing analysis results
    flagged = db.Column(db.Boolean, default=False)  # Whether this thought was flagged for review
    flag_reason = db.Column(db.String(128))  # Reason for flagging
    
    def get_state_before(self):
        """Parse stored JSON state before thought."""
        if self.state_before:
            return json.loads(self.state_before)
        return {}
    
    def set_state_before(self, state_dict):
        """Store state before thought as JSON."""
        self.state_before = json.dumps(state_dict)
    
    def get_state_after(self):
        """Parse stored JSON state after thought."""
        if self.state_after:
            return json.loads(self.state_after)
        return {}
    
    def set_state_after(self, state_dict):
        """Store state after thought as JSON."""
        self.state_after = json.dumps(state_dict)
    
    def get_tags(self):
        """Parse stored JSON tags."""
        if self.tags:
            return json.loads(self.tags)
        return []
    
    def set_tags(self, tags_list):
        """Store tags as JSON."""
        self.tags = json.dumps(tags_list)
    
    def get_analysis(self):
        """Parse stored JSON analysis."""
        if self.analysis:
            return json.loads(self.analysis)
        return {}
    
    def set_analysis(self, analysis_dict):
        """Store analysis as JSON."""
        self.analysis = json.dumps(analysis_dict)

class DreamLog(db.Model):
    """
    Stores complete dream state information for diagnostic purposes.
    """
    id = db.Column(db.Integer, primary_key=True)
    dream_id = db.Column(db.Integer, index=True)  # Reference to DreamState if available
    timestamp = db.Column(db.DateTime, default=datetime.utcnow, index=True)
    
    # Dream content
    title = db.Column(db.String(256))
    content = db.Column(db.Text, nullable=False)  # Full dream content
    dream_type = db.Column(db.String(64), index=True)  # 'rem', 'consolidation', etc.
    
    # Duration
    start_time = db.Column(db.DateTime)
    end_time = db.Column(db.DateTime)
    duration_seconds = db.Column(db.Integer)
    
    # Source information
    source_memories = db.Column(db.Text)  # JSON list of memory node IDs
    pattern_activations = db.Column(db.Text)  # JSON mapping of pattern IDs to activation levels
    
    # Results
    insights_generated = db.Column(db.Text)  # JSON list of insights
    new_associations = db.Column(db.Text)  # JSON list of new memory associations
    
    # Metadata
    emotional_tone = db.Column(db.Float)
    coherence = db.Column(db.Float)
    
    # Analysis results
    analysis = db.Column(db.Text)  # JSON containing analysis results
    flagged = db.Column(db.Boolean, default=False)  # Whether this dream was flagged for review
    flag_reason = db.Column(db.String(128))  # Reason for flagging
    
    # Session info
    session_id = db.Column(db.String(64), index=True)  # To group dreams in same session
    
    def get_content(self):
        """Parse stored JSON content."""
        if self.content:
            try:
                return json.loads(self.content)
            except:
                # If not valid JSON, return as is
                return self.content
        return {}
    
    def set_content(self, content):
        """Store content as JSON if dict, otherwise as string."""
        if isinstance(content, dict):
            self.content = json.dumps(content)
        else:
            self.content = content
    
    def get_source_memories(self):
        """Parse stored JSON source memories."""
        if self.source_memories:
            return json.loads(self.source_memories)
        return []
    
    def set_source_memories(self, memory_ids):
        """Store source memories as JSON."""
        self.source_memories = json.dumps(memory_ids)
    
    def get_pattern_activations(self):
        """Parse stored JSON pattern activations."""
        if self.pattern_activations:
            return json.loads(self.pattern_activations)
        return {}
    
    def set_pattern_activations(self, activations_dict):
        """Store pattern activations as JSON."""
        self.pattern_activations = json.dumps(activations_dict)
    
    def get_insights(self):
        """Parse stored JSON insights."""
        if self.insights_generated:
            return json.loads(self.insights_generated)
        return []
    
    def set_insights(self, insights_list):
        """Store insights as JSON."""
        self.insights_generated = json.dumps(insights_list)
    
    def get_new_associations(self):
        """Parse stored JSON new associations."""
        if self.new_associations:
            return json.loads(self.new_associations)
        return []
    
    def set_new_associations(self, associations_list):
        """Store new associations as JSON."""
        self.new_associations = json.dumps(associations_list)
    
    def get_analysis(self):
        """Parse stored JSON analysis."""
        if self.analysis:
            return json.loads(self.analysis)
        return {}
    
    def set_analysis(self, analysis_dict):
        """Store analysis as JSON."""
        self.analysis = json.dumps(analysis_dict)

class ChatLog(db.Model):
    """
    Stores complete chat interactions for diagnostic purposes.
    """
    id = db.Column(db.Integer, primary_key=True)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow, index=True)
    
    # Message content
    message_type = db.Column(db.String(64), index=True)  # 'user', 'system', 'error'
    content = db.Column(db.Text, nullable=False)  # The actual message
    
    # Conversation context
    conversation_id = db.Column(db.String(64), index=True)  # To group messages in same conversation
    parent_message_id = db.Column(db.Integer)  # For threading/replies
    
    # User info
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)
    
    # System state
    system_state = db.Column(db.Text)  # JSON representation of system state when message was processed
    
    # Processing metadata
    processing_time_ms = db.Column(db.Float)  # How long it took to process
    
    # Response details (for system messages)
    response_to = db.Column(db.Integer)  # ID of message this is responding to
    response_type = db.Column(db.String(64))  # Type of response generated
    
    # Analysis results
    analysis = db.Column(db.Text)  # JSON containing analysis results
    flagged = db.Column(db.Boolean, default=False)  # Whether this message was flagged for review
    flag_reason = db.Column(db.String(128))  # Reason for flagging
    
    def get_system_state(self):
        """Parse stored JSON system state."""
        if self.system_state:
            return json.loads(self.system_state)
        return {}
    
    def set_system_state(self, state_dict):
        """Store system state as JSON."""
        self.system_state = json.dumps(state_dict)
    
    def get_analysis(self):
        """Parse stored JSON analysis."""
        if self.analysis:
            return json.loads(self.analysis)
        return {}
    
    def set_analysis(self, analysis_dict):
        """Store analysis as JSON."""
        self.analysis = json.dumps(analysis_dict)

class DiagnosticConfig(db.Model):
    """
    Configuration for the diagnostic logging system.
    """
    id = db.Column(db.Integer, primary_key=True)
    last_updated = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Logging configuration
    enabled = db.Column(db.Boolean, default=True)  # Master switch for all diagnostic logging
    log_thoughts = db.Column(db.Boolean, default=True)
    log_dreams = db.Column(db.Boolean, default=True)
    log_chats = db.Column(db.Boolean, default=True)
    
    # Retention policy
    retention_days = db.Column(db.Integer, default=90)  # How long to keep logs (0 = forever)
    
    # Sampling rate (to reduce storage for high-volume systems)
    thought_sampling_rate = db.Column(db.Float, default=1.0)  # Percentage of thoughts to log (0.0-1.0)
    
    # Analysis configuration
    perform_analysis = db.Column(db.Boolean, default=False)  # Whether to analyze logs
    analysis_delay_seconds = db.Column(db.Integer, default=3600)  # Delay before analyzing
    
    # Flagging configuration
    flagging_enabled = db.Column(db.Boolean, default=True)  # Whether to flag concerning logs
    flagging_criteria = db.Column(db.Text)  # JSON for flagging criteria
    
    def get_flagging_criteria(self):
        """Parse stored JSON flagging criteria."""
        if self.flagging_criteria:
            return json.loads(self.flagging_criteria)
        return {}
    
    def set_flagging_criteria(self, criteria_dict):
        """Store flagging criteria as JSON."""
        self.flagging_criteria = json.dumps(criteria_dict)